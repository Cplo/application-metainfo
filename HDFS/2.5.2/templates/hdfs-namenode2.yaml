<#assign
  registryServer=dependencies.REGISTRY.roles['REGISTRY_SERVER'][0].hostname
  registryPort=dependencies.REGISTRY['registry.port']
  >
<#--federation is true-->
<#if service.nameservices?? && service.nameservices?size gt 0>
<#list service.nameservices as ns>
<#--ha is enabled-->
    <#if service[ns]['HDFS_NAMENODE']?size gt 1>
    <#assign
        namenode1hostname=service[ns]['HDFS_NAMENODE'][0].hostname
        namenode2hostname=service[ns]['HDFS_NAMENODE'][1].hostname
        namenode1nodeid=service[ns]['HDFS_NAMENODE'][0].id
        namenode2nodeid=service[ns]['HDFS_NAMENODE'][1].id
        namenode_http_port=service['namenode.http-port']
    >
    </#if>
    <#if namenode2nodeid gt namenode1nodeid>
        <#assign minhostname=namenode1hostname >
    <#else>
        <#assign minhostname=namenode2hostname >
    </#if>
    <#if minhostname == localhostname>
        <#assign namenode_id="'0'" >
    <#else>
        <#assign namenode_id="'1'" >
    </#if>
</#list>
<#else>
<#--federation is false-->
</#if>
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    name: hadoop-hdfs-namenode-${service.sid}-${namenode2hostname}
  name: hadoop-hdfs-namenode-${service.sid}-${namenode2hostname}
  namespace: default
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        name: hadoop-hdfs-namenode-${service.sid}-${namenode2hostname}
        podConflictName: hdfs-namenode
    spec:
      containers:
      - args:
        - bootstrap.sh
        - namenode
        env:
        - name: KRB_ENABLE
          value: 'false'
        - name: HADOOP_HA_NAMENODE_SERVICE
          value: ${namenode1hostname},${namenode2hostname}
        - name: HDFS_JOURNAL_NODE_SPEC
          value: valid
        - name: HDFS_HA
          value: 'true'
        - name: NAMENODE_ID
          value: '1'
        - name: SPEC
          value: ${localhostname}
        - name: HADOOP_CONF_DIR
          value: /etc/${service.sid}/conf
        - name: DATA_DIRS
          value: ${service['dfs.namenode.name.dir']?trim}
        - name: HEAP_SIZE
          value: ${service['namenode.memory']?trim}m
        - name: SOCKETDIR
          value: /var/run/${service.sid}
        image: ${registryServer}:${registryPort}/jenkins/hdfs
        imagePullPolicy: Always
#        readinessProbe:
#          httpGet:
#            port: ${namenode_http_port}
#            path: /dfshealth.html
#          initialDelaySeconds: 60
        name: hadoop-hdfs-namenode-${service.sid}-${namenode2hostname}
        # The path mounts on docker
        volumeMounts:
        - mountPath: /etc/${service.sid}/conf
          name: hdfs
        - mountPath: /var/run/hadoop-common
          name: socketdir
        - mountPath: /var/transwarp/logs
          name: log
        - mountPath: /var/transwarp/data
          name: format
        - mountPath: /etc/transwarp/conf/
          name: topology
        - mountPath: /var/run/${service.sid}
          name: hdfssocketdir
<#list service['dfs.namenode.name.dir']?split(",") as datadir>
        - mountPath: ${datadir?trim}
          name: namenodedir${datadir_index}
</#list>
      - args:
        - bootstrap.sh
        - zkfc
        env:
        - name: HDFS_HA
          value: 'true'
        - name: KRB_ENABLE
          value: 'false'
        - name: HADOOP_HA_NAMENODE_SERVICE
          value: ${namenode1hostname},${namenode2hostname}
        - name: CLUSTER
          value: ${service.sid}
        - name: HDFS_JOURNAL_NODE_SPEC
          value: valid
        - name: HADOOP_CONF_DIR
          value: /etc/${service.sid}/conf
        image: ${registryServer}:${registryPort}/jenkins/hdfs
        imagePullPolicy: Always
        name: zkfc
        # The path mounts on docker
        volumeMounts:
        - mountPath: /etc/${service.sid}/conf
          name: hdfs
        - mountPath: /var/run/hadoop-common
          name: socketdir
        - mountPath: /var/transwarp/logs
          name: log
      hostNetwork: true
      # Ensure that a node can have one hdfs-namenode at most
      podConflictSelectors:
      - matchExpressions:
        - key: podConflictName
          operator: "="
          values:
          - "hdfs-namenode"
      # Ensure that only the node labeled "hdfs-namenode" can start a hdfs-namenode role (i.e., a pod)
      nodeSelector:
        hdfs-namenode: "true"
      # The path on real node
      volumes:
      - hostPath:
          path: /var/log/${service.sid}
        name: log
      - hostPath:
          path: /etc/${service.sid}/conf
        name: hdfs
      - hostPath:
          path: /root/docker/common
        name: socketdir
      - hostPath:
          path: /var/namenode_format/
        name: format
      - hostPath:
          path: /etc/transwarp/conf/
        name: topology
      - hostPath:
          path: /var/run/${service.sid}
        name: hdfssocketdir
<#list service['dfs.namenode.name.dir']?split(",") as datadir>
      - hostPath:
          path: ${datadir?trim}
        name: namenodedir${datadir_index}
</#list>
